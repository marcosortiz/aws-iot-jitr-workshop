const fs          = require('fs');
const resolve     = require('path').resolve;
const program     = require('commander');
const Chain       = require('middleware-chain-js');
const mkdirp      = require('mkdirp');
const UUID        = require('uuid-1345');
const concat      = require('concat');
const openssl     = require('./lib/openssl');
const mqttConnect = require('./lib/mqtt-connect');
const chain       = new Chain();

// Retrieving package informations.
const { version, description, name } = require('./package.json');

// The output directory.
const OUTPUT_DIRECTORY = './device-certs';

// Sample country and city locations.
const countries = [
  { code: 'US', locality: 'United-States', city: 'Seattle' },
  { code: 'US', locality: 'United-States', city: 'New-York' },
  { code: 'FR', locality: 'France', city: 'Paris' },
  { code: 'SE', locality: 'Sweden', city: 'Stockholm' },
  { code: 'LU', locality: 'Luxembourg', city: 'Luxembourg' },
  { code: 'DE', locality: 'Deutschland', city: 'Berlin' },
  { code: 'DE', locality: 'Deutschland', city: 'Munich' },
  { code: 'UK', locality: 'United-Kingdom', city: 'London' },
  { code: 'UK', locality: 'Switzerland', city: 'Geneve' },
  { code: 'ES', locality: 'Espana', city: 'Madrid' },
  { code: 'AE', locality: 'UAE', city: 'Dubai' }
];

/**
 * Command-line interface.
 */
program
  .version(version)
  .name(name)
  .description(description)
  .option('-r, --root-ca-directory <root-ca-directory>', 'Specifies the directory path of the Root CA to use to generate device certificates.')
  .option('-a, --aws-root-ca <aws-root-ca>', 'Specifies the path to the AWS Root CA to use to connect the virtual devices to AWS IoT.')
  .option('-e, --endpoint <endpoint>', 'Specifies the AWS IoT endpoint to connect to.')
  .option('-t, --type <type>', 'Specifies the virtual device type to create (can be `iot` or `greengrass`).')
  .option('-n, --number [number]', 'Specifies the number of virtual devices to connect to AWS IoT (by default, only 1 device is created and connected).')
  .parse(process.argv);

/**
 * Fails the application with the given `message`.
 * @param {*} message the message to display upon
 * a failure.
 */
const fail = (message) => {
  console.error(`[!] ${message}`);
  process.exit(1);
};

/**
 * Equivalent of `mkdir -p` as a promise.
 * @param {*} dir the directory path(s) to create.
 */
const asyncMkdirp = (dir) => {
  return new Promise((resolve, reject) => {
    mkdirp(dir, (err) => err ? reject(err) : resolve(dir));
  });
};

/**
* @return a random integer between min (inclusive) and max (inclusive).
* The value is no lower than min (or the next integer greater than min
* if min isn't an integer) and no greater than max (or the next integer
* lower than max if max isn't an integer).
*/
const getRandomInt = (min, max) => {
  min = Math.ceil(min);
  max = Math.floor(max);
  return (Math.floor(Math.random() * (max - min + 1)) + min);
};

/**
 * Generates a device certificate.
 * @param {*} rootCaDir the directory of the Root CA directory.
 * @param {*} type the device type to create.
 */
const generateDeviceCertificate = (rootCaDir, type) => {
  const serialNumber = UUID.v4();
  const thingName = `thing-${serialNumber}`;
  const outputDir = `${OUTPUT_DIRECTORY}/${serialNumber}`;
  const index = getRandomInt(0, countries.length - 1);

  return asyncMkdirp(`./device-certs/${serialNumber}`)
    // Creates a new private key.
    .then(() => openssl(`genrsa -out ${outputDir}/device-certificate.key 2048`))
    // Creates a CSR with the certificate subject fields to use.
    .then(() => openssl(`req \
      -new \
      -subj "/CN=${thingName}/O=Acme/OU=AcmeUnit/2.5.4.44=smart-sensor/title=${type}/C=${countries[index].code}/L=${countries[index].locality}/ST=${countries[index].city}/serialNumber=${serialNumber}" \
      -key ${outputDir}/device-certificate.key \
      -out ${outputDir}/device-certificate.csr`))
    // Creates the device certificate.
    .then(() => openssl(`x509 \
      -req \
      -in ${outputDir}/device-certificate.csr \
      -CA ${rootCaDir}/ca-certificate.pem \
      -CAkey ${rootCaDir}/ca-certificate.key \
      -CAcreateserial \
      -CAserial ${outputDir}/device-certificate.srl \
      -out ${outputDir}/device-certificate.crt \
      -days 365 \
      -sha256`))
    // Concatenates the device certificate and the Root CA.
    .then(() => concat([`${outputDir}/device-certificate.crt`, `${rootCaDir}/ca-certificate.pem`]))
    // Creates the end device certificate.
    .then((result) => {
      fs.writeFileSync(`${outputDir}/device-and-ca-certificate.crt`, result);
      console.log(` [+] Successfully created device certificate for thing '${thingName}' (Type=${type}, Country=${countries[index].locality}, City=${countries[index].city}).`);
      return ({
        deviceCertificate: resolve(`${outputDir}/device-and-ca-certificate.crt`),
        devicePrivateKey: resolve(`${outputDir}/device-certificate.key`),
        thingName: thingName,
        serialNumber: serialNumber
      });
    });
};

/**
 * Generates device certificates for as many devices
 * as `number`.
 * @param {*} number the number of certificates to generate.
 * @param {*} rootCaDir the directory of the Root CA directory.
 * @param {*} type the device type to create.
 */
const generateDeviceCertificates = (number, rootCaDir, type) => {
  const promises = [];
  for (let i = 0; i < number; ++i) {
    promises.push(generateDeviceCertificate(rootCaDir, type));
  }
  return (Promise.all(promises));
};

/**
 * Initiates the connection of the given device
 * to AWS IoT.
 * @param {*} location certificate locations associated
 * with the device to connect to AWS IoT.
 */
const connectDevice = (location, rootCa, endpoint) => {
  return (mqttConnect(location, rootCa, endpoint));
};

/**
 * Initiates the connection of the given devices
 * to AWS IoT.
 * @param {*} locations an array of certificate locations
 * associated with the devices to connect to AWS IoT.
 */
const connectDevices = (locations, rootCa, endpoint) => {
  return (Promise.all(locations.map((location) => connectDevice(location, rootCa, endpoint))));
};

/**
 * Verifying that the given parameters are correct.
 */
chain.use((input, output, next) => {
  if (!program.rootCaDirectory || !program.awsRootCa || !program.endpoint) {
    return (fail('The parameters `root-ca-directory`, `aws-root-ca` and `endpoint` are required.'));
  }
  // If the specified amount of devices is not a number, we fail.
  if (program.number && !Number.isInteger(program.number) && (program.number === 0 || program.number > 500)) {
    return (fail('The given amount of devices to generate must be a valid integer between 1 and 500.'));
  }
  // Validating the device type.
  if (program.type && program.type !== 'iot' && program.type !== 'greengrass') {
    return (fail('The given device type must be either `iot` or `greengrass`.'));
  }
  // Normalizing paths.
  input.rootCaDirectory = resolve(program.rootCaDirectory);
  input.awsRootCa = resolve(program.awsRootCa);
  // Setting the number of devices to generate.
  input.number = program.number ? program.number : 1;
  // Setting the device type.
  input.type = program.type ? program.type : 'iot';
  next();
});

/**
 * Verifying that the given path exist.
 */
chain.use((input, output, next) => {
  // Verifying the presence of the Root CA directory.
  try {
    if (!fs.statSync(input.rootCaDirectory).isDirectory()) {
      return (fail(`The 'root-ca-directory' parameter must be a valid path to a directory on the file system.`));
    }
  } catch (e) { fail(e) }
  // Verifying the presence of the AWS Root CA certificate.
  try {
    if (!fs.statSync(input.awsRootCa).isFile()) {
      return (fail(`The 'aws-root-ca' parameter must be a valid path to the AWS Root CA on the file system.`));
    }
  } catch (e) { fail(e) }
  next();
});

/**
 * Generating certificates for the given amount of devices.
 */
chain.use((input, output, next) => {
  console.log(`[+] Creating ${input.number} device certificate(s) ...`);
  generateDeviceCertificates(input.number, input.rootCaDirectory, input.type)
    .then((locations) => {
      console.log(`[+] Successfully created ${input.number} device certificate(s) in '${OUTPUT_DIRECTORY}'.`);
      next(input.locations = locations);
    })
    .catch(fail);
});

/**
 * Connecting the virtual devices to AWS IoT.
 */
chain.use((input) => {
  console.log(`[+] Connecting ${input.number} virtual device(s) to AWS IoT ...`);
  connectDevices(input.locations, input.awsRootCa, program.endpoint)
    .then((clients) => {
      console.log(`[+] Successfully connected ${input.number} devices to AWS IoT, disconnecting ...`);
      // Disconnecting the virtual devices from AWS IoT.
      clients.forEach((client) => client.end());
    })
    .catch(fail);
});

// Starting the chain.
chain.handle({}, {});